import random

def pick_up_floor(lobby, elevator, passengers, floor, i):
    amount = lobby[floor - 1]

    # Load as many passengers as possible to the chosen floor
    actual_amount = min(amount, elevator.max_capacity - len(passengers[i]))
    passengers[i] += [floor] * actual_amount
    lobby[floor - 1] -= actual_amount


def random_passenger_assignment(lobby, elevators):  # generated by ChatGPT-4o
    passengers = [
        [] for _ in range(len(elevators))
    ]  # Initialize empty passenger lists for each elevator

    # Iterate over the elevators to assign passengers
    for i, elevator in enumerate(elevators):
        if elevator.available_in == 0:  # Check if the elevator is available
            while len(passengers[i]) < elevator.max_capacity and any(lobby):
                # Randomly choose a floor from the available floors in the lobby
                floor = random.choice(
                    [i + 1 for i in range(len(lobby)) if lobby[i] > 0]
                )

                # Load one passenger to the chosen floor
                passengers[i].append(floor)
                lobby[
                    floor - 1
                ] -= 1  # Decrease the count of waiting passengers for this floor

    return passengers


def max_passenger_assignment(lobby, elevators):
    passengers = [[] for _ in range(len(elevators))]

    for i, elevator in enumerate(elevators):
        if elevator.available_in == 0:
            while len(passengers[i]) < elevator.max_capacity and any(lobby):
                max_floor = lobby.index(max(lobby)) + 1
                pick_up_floor(lobby, elevator, passengers, max_floor, i)

    return passengers


def match_check_passenger_assignment(lobby, elevators):
    passengers = [[] for _ in range(len(elevators))]

    for i, elevator in enumerate(elevators):
        if elevator.available_in == 0:
            iterations = 0
            while len(passengers[i]) < elevator.max_capacity and any(lobby):
                if (
                    iterations == 1
                    and (elevator.max_capacity - len(passengers[i])) in lobby
                ):
                    floor = lobby.index(elevator.max_capacity - len(passengers[i])) + 1
                    pick_up_floor(lobby, elevator, passengers, floor, i)
                    break

                max_floor = lobby.index(max(lobby)) + 1
                pick_up_floor(lobby, elevator, passengers, max_floor, i)

                iterations += 1

    return passengers


def proximity_passenger_assignment(lobby, elevators):
    passengers = [[] for _ in range(len(elevators))]

    for i, elevator in enumerate(elevators):
        if elevator.available_in == 0:
            iterations = 0
            direction = "up"

            while len(passengers[i]) < elevator.max_capacity and any(lobby):
                if iterations > 0:
                    if (
                        iterations == 1
                        and (elevator.max_capacity - len(passengers[i])) in lobby
                    ):
                        floor = (
                            lobby.index(elevator.max_capacity - len(passengers[i])) + 1
                        )
                        pick_up_floor(lobby, elevator, passengers, floor, i)
                        break
                    else:
                        if direction == "up" and (max_floor - 1) - iterations >= 0:
                            if (max_floor - 1) - iterations == 0:
                                direction = "down"
                                iterations = 1
                                break
                            pick_up_floor(
                                lobby, elevator, passengers, max_floor - iterations, i
                            )
                        elif (
                            direction == "down"
                            and (max_floor - 1) + iterations < elevator.max_capacity
                        ):
                            pick_up_floor(
                                lobby, elevator, passengers, max_floor + iterations, i
                            )
                        iterations += 1
                        break

                max_floor = lobby.index(max(lobby)) + 1
                pick_up_floor(lobby, elevator, passengers, max_floor, i)

                iterations += 1

    return passengers


def no_match_check_proximity_passenger_assignment(lobby, elevators):
    passengers = [[] for _ in range(len(elevators))]

    for i, elevator in enumerate(elevators):
        if elevator.available_in == 0:
            iterations = 0
            direction = "up"

            while len(passengers[i]) < elevator.max_capacity and any(lobby):
                if iterations > 0:
                    if direction == "up" and (max_floor - 1) - iterations >= 0:
                        if (max_floor - 1) - iterations == 0:
                            direction = "down"
                            iterations = 1
                            break
                        pick_up_floor(
                            lobby, elevator, passengers, max_floor - iterations, i
                        )
                    elif (
                        direction == "down"
                        and (max_floor - 1) + iterations < elevator.max_capacity
                    ):
                        pick_up_floor(
                            lobby, elevator, passengers, max_floor + iterations, i
                        )
                    iterations += 1
                    break

                max_floor = lobby.index(max(lobby)) + 1
                pick_up_floor(lobby, elevator, passengers, max_floor, i)

                iterations += 1

    return passengers
