import numpy as np
import matplotlib.pyplot as plt
from constants import (
    employee_floor_distribution,
    mean_arrival_time,
    std_dev,
    start_time,
    end_time,
)


def generate_arrival_times(
    employee_floor_distribution, mean_time, std_dev, start_time, end_time
):  # generated using ChatGPT-4o
    """
    Generates arrival times paired with floor numbers for each person.

    Parameters:
    - employee_floor_distribution: A list where each index corresponds to a floor and the value is the number of people on that floor.
    - mean_time: Mean arrival time for the distribution.
    - std_dev: Standard deviation of the arrival times.
    - start_time: The earliest time an employee can arrive.
    - end_time: The latest time an employee can arrive.

    Returns:
    - A list of tuples where each tuple is (floor_number, arrival_time).
    """
    all_arrival_times = []

    for floor, num_people in enumerate(employee_floor_distribution, start=1):
        arrival_times = np.random.normal(loc=mean_time, scale=std_dev, size=num_people)
        arrival_times = np.clip(arrival_times, start_time, end_time)
        arrival_times.sort()

        # Pair each arrival time with the floor number
        paired_times = [(floor, arrival_time) for arrival_time in arrival_times]
        all_arrival_times.extend(paired_times)

    # Sort all arrival times across all floors
    all_arrival_times.sort(key=lambda x: x[0])

    return all_arrival_times


def plot_times(
    times,
    bin_width=50,  # Default bin width
    scale=1,
    left_bound=None,
    right_bound=None,
):  # partially generated by ChatGPT-4o
    min_time = min(time for _, time in times)
    max_time = max(time for _, time in times)

    rounded_min_time = np.floor(min_time / bin_width) * bin_width
    rounded_max_time = np.ceil(max_time / bin_width) * bin_width

    # Calculate the number of bins needed
    bins = np.arange(rounded_min_time, rounded_max_time + bin_width, bin_width)

    # Separate arrival times by floor
    floors = list(set(floor for floor, _ in times))
    floor_colors = plt.cm.viridis(np.linspace(0, 1, len(floors)))

    # Initialize the stacked histogram data
    hist_data = {floor: np.zeros(len(bins) - 1) for floor in floors}

    # Calculate the histogram for each floor
    for floor in floors:
        # Extract arrival times for this floor
        floor_times = [time for flr, time in times if flr == floor]

        # Compute histogram for this floor
        hist, _ = np.histogram(floor_times, bins=bins)
        hist_data[floor] = hist * scale

    plt.figure(figsize=(12, 6))

    # Stack the histograms
    bottom = np.zeros(len(bins) - 1)
    for floor, color in zip(floors, floor_colors):
        plt.bar(
            bins[:-1] + bin_width / 2,  # Center bars over bins
            hist_data[floor],
            width=bin_width,
            bottom=bottom,
            color=color,
            edgecolor="black",
            alpha=0.7,
            label=f"Floor {floor}",
        )
        bottom += hist_data[floor]

    # Add labels and legend
    plt.xlim(left_bound, right_bound)
    plt.xlabel("Arrival Time (seconds)")
    plt.ylabel("Number of Arrivals")
    plt.title("Employee Arrival Times by Floor")
    plt.legend(title="Floor")
    plt.grid(True)
    plt.show()


def plot_one():
    arrival_times = generate_arrival_times(
        employee_floor_distribution,
        mean_arrival_time,
        std_dev,
        start_time,
        end_time,
    )

    print("len(arrival_times):", len(arrival_times))
    print("type(arrival_times):", type(arrival_times))
    plot_times(arrival_times)


def plot_many():
    amount = 10000

    arrival_times_2d = [
        generate_arrival_times(
            employee_floor_distribution,
            mean_arrival_time,
            std_dev,
            start_time,
            end_time,
        )
        for _ in range(amount)
    ]

    arrival_times_1d = [
        time for arrival_times in arrival_times_2d for time in arrival_times
    ]

    print("len(arrival_times):", len(arrival_times_1d))
    print("type(arrival_times):", type(arrival_times_1d))
    plot_times(arrival_times_1d, scale=1 / amount)


if __name__ == "__main__":
    plot_many()
